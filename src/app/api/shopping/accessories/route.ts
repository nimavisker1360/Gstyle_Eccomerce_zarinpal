import { NextRequest, NextResponse } from "next/server";
import { getJson } from "serpapi";
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";

// Function to extract and validate product links from SERP API
function extractProductLink(product: any): string | null {
  // List of valid store domains we want to accept
  const validStoreDomains = [
    "hepsiburada.com",
    "trendyol.com",
    "n11.com",
    "gittigidiyor.com",
    "amazon.com.tr",
    "amazon.com",
    "amazon.de",
    "amazon.co.uk",
    "ebay.com",
    "ebay.de",
    "ebay.co.uk",
    "etsy.com",
    "asos.com",
    "zara.com",
    "hm.com",
    "mango.com",
    "pullandbear.com",
    "bershka.com",
    "stradivarius.com",
    "massimodutti.com",
    "oysho.com",
    "zara.com.tr",
    "hm.com.tr",
    "mango.com.tr",
    "sephora.com",
    "sephora.com.tr",
    "douglas.com",
    "douglas.com.tr",
    "flormar.com.tr",
    "goldenrose.com.tr",
    "lorealparis.com.tr",
    "maybelline.com.tr",
    "nyxcosmetics.com.tr",
    "mac.com.tr",
    "benefitcosmetics.com.tr",
    "clinique.com.tr",
    "esteelauder.com.tr",
    "lancome.com.tr",
    "dior.com",
    "chanel.com",
    "ysl.com",
    "gucci.com",
    "prada.com",
    "louisvuitton.com",
    "hermes.com",
    "cartier.com",
    "tiffany.com",
    "swarovski.com",
    "pandora.com",
    "cartier.com.tr",
    "tiffany.com.tr",
    "swarovski.com.tr",
    "pandora.com.tr",
  ];

  // Function to check if URL is from a valid store
  function isValidStoreUrl(url: string): boolean {
    if (!url || typeof url !== "string") return false;

    // Exclude Google Shopping links
    if (
      url.includes("google.com/shopping") ||
      url.includes("google.com.tr/shopping") ||
      url.includes("google.com/search?tbm=shop")
    ) {
      return false;
    }

    // Check if URL contains any valid store domain
    return validStoreDomains.some((domain) => url.includes(domain));
  }

  // Priority order for extracting product links
  const linkSources = [
    product.merchant?.link,
    product.merchant?.url,
    product.source_link,
    product.product_link,
    product.offers?.link,
    product.offers?.url,
    product.link,
  ];

  // Debug: Log all available links for this product
  console.log(`üîç Debugging product: ${product.title}`);
  console.log(`  Available links:`);
  linkSources.forEach((link, index) => {
    if (link) {
      console.log(`    ${index + 1}. ${link}`);
    }
  });

  // Try to find a valid store link
  for (const link of linkSources) {
    if (link && isValidStoreUrl(link)) {
      console.log(`‚úÖ Found valid store link: ${link}`);
      return link;
    }
  }

  console.log(`‚ùå No valid store link found for: ${product.title}`);
  return null;
}

// Function to filter out laptops and computers
function filterOutComputersAndLaptops(product: any): boolean {
  const title = product.title?.toLowerCase() || "";
  const description = product.description?.toLowerCase() || "";

  // Filter out women's underwear products
  const underwearKeywords = [
    // Persian
    "⁄©ŸàŸÑŸàÿ™",
    "ŸæŸàÿ¥ÿß⁄© ÿ≤€åÿ±",
    "ŸÑ€åŸÜÿ¨ÿ±€å",
    // English
    "panties",
    "underwear",
    "lingerie",
    "slip",
    "thong",
    "g-string",
    "briefs",
    "bikini",
    "swimwear",
    // Turkish
    "k√ºlot",
    "pamuklu",
    "i√ß √ßama≈üƒ±rƒ±",
    "mayo",
    "bikini",
    "plaj giyim",
    "gece elbisesi",
    "gece kƒ±yafeti",
  ];

  // Check if product contains underwear keywords - if yes, exclude it
  if (
    underwearKeywords.some(
      (keyword) => title.includes(keyword) || description.includes(keyword)
    )
  ) {
    return false;
  }

  // Keywords that indicate complete laptops or computers (not accessories)
  const computerKeywords = [
    "laptop bilgisayar",
    "diz√ºst√º bilgisayar",
    "masa√ºst√º bilgisayar",
    "desktop computer",
    "bilgisayar sistemi",
    "computer system",
    "macbook pro",
    "macbook air",
    "thinkpad laptop",
    "dell laptop",
    "hp laptop",
    "lenovo laptop",
    "asus laptop",
    "acer laptop",
    "msi laptop",
    "gaming laptop",
    "oyun bilgisayarƒ±",
    "i≈ü bilgisayarƒ±",
    "ev bilgisayarƒ±",
    "tam bilgisayar",
    "complete computer",
    "bilgisayar takƒ±mƒ±",
    "computer set",
  ];

  // Keywords that indicate accessories (should NOT be filtered)
  const accessoryKeywords = [
    "klavye",
    "keyboard",
    "mouse",
    "maus",
    "headphone",
    "kulaklƒ±k",
    "speaker",
    "hoparl√∂r",
    "charger",
    "≈üarj",
    "cable",
    "kablo",
    "adapter",
    "adapt√∂r",
    "case",
    "kƒ±lƒ±f",
    "cover",
    "kapak",
    "stand",
    "ayak",
    "holder",
    "tutucu",
    "dock",
    "istasyon",
    "hub",
    "hub",
    "docking station",
    "istasyon",
    "wireless",
    "kablosuz",
    "bluetooth",
    "bluetooth",
    "usb",
    "usb",
    "hdmi",
    "hdmi",
    "vga",
    "vga",
    "displayport",
    "displayport",
    "ethernet",
    "ethernet",
    "wifi",
    "wifi",
    "antenna",
    "anten",
    "battery",
    "pil",
    "power bank",
    "powerbank",
    "≈üarj cihazƒ±",
    "charging device",
    "cable",
    "kablo",
    "wire",
    "tel",
    "connector",
    "baƒülantƒ±",
    "splitter",
    "ayƒ±rƒ±cƒ±",
    "converter",
    "d√∂n√º≈üt√ºr√ºc√º",
    "extender",
    "uzatƒ±cƒ±",
    "repeater",
    "tekrarlayƒ±cƒ±",
    "switch",
    "anahtar",
    "router",
    "y√∂nlendirici",
    "modem",
    "modem",
    "network",
    "aƒü",
    "storage",
    "depolama",
    "memory",
    "bellek",
    "ram",
    "ram",
    "ssd",
    "ssd",
    "hard disk",
    "sabit disk",
    "flash drive",
    "flash bellek",
    "memory card",
    "bellek kartƒ±",
    "sd card",
    "sd kart",
    "micro sd",
    "micro sd",
    "card reader",
    "kart okuyucu",
    "webcam",
    "web kamera",
    "camera",
    "kamera",
    "microphone",
    "mikrofon",
    "mic",
    "mikrofon",
    "audio",
    "ses",
    "video",
    "video",
    "graphics",
    "grafik",
    "gpu",
    "gpu",
    "processor",
    "i≈ülemci",
    "cpu",
    "cpu",
    "motherboard",
    "anakart",
    "power supply",
    "g√º√ß kaynaƒüƒ±",
    "psu",
    "psu",
    "cooling",
    "soƒüutma",
    "fan",
    "fan",
    "heatsink",
    "ƒ±sƒ± emici",
    "thermal",
    "termal",
    "paste",
    "macun",
    "thermal paste",
    "termal macun",
    "monitor",
    "ekran",
    "display",
    "g√∂r√ºnt√º",
    "screen",
    "ekran",
    "projector",
    "projeksiyon",
    "printer",
    "yazƒ±cƒ±",
    "scanner",
    "tarayƒ±cƒ±",
    "all in one",
    "hepsi bir arada",
    "desktop",
    "masa√ºst√º",
    "tower",
    "kule",
    "mini pc",
    "mini bilgisayar",
    "stick pc",
    "√ßubuk bilgisayar",
    "nuc",
    "nuc",
    "barebone",
    "√ßƒ±plak",
    "kit",
    "kit",
    "bundle",
    "paket",
    "combo",
    "kombinasyon",
    "set",
    "set",
    "package",
    "paket",
    "complete",
    "tam",
    "full",
    "tam",
    "system",
    "sistem",
  ];

  // Check if product contains computer/laptop keywords (excluding accessories)
  const isCompleteComputer = computerKeywords.some(
    (keyword) => title.includes(keyword) || description.includes(keyword)
  );

  // Check if product contains accessory keywords
  const isAccessory = accessoryKeywords.some(
    (keyword) => title.includes(keyword) || description.includes(keyword)
  );

  // If it's a complete computer/laptop, filter it out
  if (isCompleteComputer && !isAccessory) {
    console.log(`üö´ Filtered out complete computer/laptop: ${product.title}`);
    return false;
  }

  // If it's an accessory, keep it
  if (isAccessory) {
    console.log(`‚úÖ Kept accessory: ${product.title}`);
    return true;
  }

  // For products that don't clearly match either category, keep them for manual review
  console.log(`ü§î Uncertain product (keeping): ${product.title}`);
  return true;
}

// Function to enhance search query with OpenAI
async function enhanceSearchQuery(query: string): Promise<string> {
  if (!process.env.OPENAI_API_KEY) {
    return query;
  }

  try {
    const enhancedQueryPrompt = `
      ŸÖŸÜ €å⁄© ⁄©Ÿàÿ¶ÿ±€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿØÿßÿ±ŸÖ ⁄©Ÿá ÿ®ÿß€åÿØ ÿ¢ŸÜ ÿ±ÿß ÿ®ÿ±ÿß€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å ŸÑŸàÿßÿ≤ŸÖ ÿ¨ÿßŸÜÿ®€å ⁄©ÿßŸÖŸæ€åŸàÿ™ÿ± Ÿà ŸÖŸàÿ®ÿß€åŸÑ ÿØÿ± ŸÅÿ±Ÿàÿ¥⁄ØÿßŸá‚ÄåŸáÿß€å ÿ¢ŸÜŸÑÿß€åŸÜ ÿ™ÿ±⁄©€åŸá ÿ®Ÿáÿ®ŸàÿØ ÿØŸáŸÖ.
      
      ŸÇŸàÿßŸÜ€åŸÜ ŸÖŸáŸÖ:
      1. ŸÅŸÇÿ∑ ŸÑŸàÿßÿ≤ŸÖ ÿ¨ÿßŸÜÿ®€å ⁄©ÿßŸÖŸæ€åŸàÿ™ÿ± Ÿà ŸÖŸàÿ®ÿß€åŸÑ ÿ±ÿß ÿ¥ÿßŸÖŸÑ ÿ¥ŸàÿØ
      2. ŸÑŸæ ÿ™ÿßŸæ Ÿà ⁄©ÿßŸÖŸæ€åŸàÿ™ÿ± ⁄©ÿßŸÖŸÑ ÿ±ÿß ÿ≠ÿ∞ŸÅ ⁄©ŸÜ
      3. ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ÿ™ÿ±⁄©€å ÿ™ÿ±ÿ¨ŸÖŸá ⁄©ŸÜ
      4. ⁄©ŸÑŸÖÿßÿ™ ⁄©ŸÑ€åÿØ€å ŸÖŸÜÿßÿ≥ÿ® ÿ®ÿ±ÿß€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØÿ± ÿ™ÿ±⁄©€åŸá ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ
      5. ⁄©ŸÑŸÖÿßÿ™ ⁄©ŸÑ€åÿØ€å ŸÑŸàÿßÿ≤ŸÖ ÿ¨ÿßŸÜÿ®€å ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ ŸÖÿ´ŸÑ: klavye, mouse, kulaklƒ±k, ≈üarj, kƒ±lƒ±f, adapt√∂r
      
      ŸÖÿ´ÿßŸÑ‚ÄåŸáÿß€å ⁄©ŸÑŸÖÿßÿ™ ⁄©ŸÑ€åÿØ€å ŸÑŸàÿßÿ≤ŸÖ ÿ¨ÿßŸÜÿ®€å:
      - ⁄©€åÿ®Ÿàÿ±ÿØ: klavye, keyboard
      - ŸÖŸàÿ≥: mouse, maus
      - ŸáÿØÿ≥ÿ™: kulaklƒ±k, headphone
      - ÿ¥ÿßÿ±⁄òÿ±: ≈üarj, charger
      - ŸÇÿßÿ®: kƒ±lƒ±f, case, cover
      - ⁄©ÿßÿ®ŸÑ: kablo, cable
      - ÿ¢ÿØÿßŸæÿ™Ÿàÿ±: adapt√∂r, adapter
      
      ⁄©Ÿàÿ¶ÿ±€å ÿßÿµŸÑ€å: "${query}"
      
      ŸÑÿ∑ŸÅÿßŸã ⁄©Ÿàÿ¶ÿ±€å ÿ±ÿß ÿ®Ÿáÿ®ŸàÿØ ÿØÿßÿØŸá Ÿà ÿ®Ÿá ÿ™ÿ±⁄©€å ÿ™ÿ±ÿ¨ŸÖŸá ⁄©ŸÜ:
    `;

    const { text: enhancedQuery } = await generateText({
      model: openai("gpt-3.5-turbo"),
      prompt: enhancedQueryPrompt,
    });

    console.log(`üîß Enhanced query: "${query}" -> "${enhancedQuery}"`);
    return enhancedQuery.trim();
  } catch (error) {
    console.error("‚ùå Error enhancing query with OpenAI:", error);
    return query;
  }
}

// Function to check if text is already in Persian
function isPersianText(text: string): boolean {
  if (!text || text.trim().length === 0) return false;

  // Persian characters range
  const persianRegex =
    /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;

  // Check if text contains Persian characters
  const hasPersianChars = persianRegex.test(text);

  // Also check for common Persian words
  const persianWords = [
    "⁄©ŸÅÿ¥",
    "ŸÖÿ±ÿØÿßŸÜŸá",
    "ŸæŸàŸÖÿß",
    "ŸÜÿß€å⁄©",
    "ÿ¢ÿØ€åÿØÿßÿ≥",
    "ŸÖÿØŸÑ",
    "ÿ±ŸÜ⁄Ø",
    "ÿ≥ÿß€åÿ≤",
    "⁄©€åŸÅ€åÿ™",
    "ÿßÿ±ÿ≤ÿßŸÜ",
    "⁄Øÿ±ÿßŸÜ",
    "ÿ™ÿÆŸÅ€åŸÅ",
  ];
  const hasPersianWords = persianWords.some((word) => text.includes(word));

  return hasPersianChars || hasPersianWords;
}

// Function to clean and validate text before translation
function cleanTextForTranslation(text: string): string {
  if (!text || typeof text !== "string") return "";

  // Remove JSON-like structures
  let cleaned = text
    .replace(
      /\{[\s]*"title"[\s]*:[\s]*"[^"]*"[\s]*,[\s]*"description"[\s]*:[\s]*"[^"]*"[\s]*\}/g,
      ""
    )
    .replace(/\{[\s]*"description"[\s]*:[\s]*"[^"]*"[\s]*\}/g, "")
    .replace(/\{[\s]*"title"[\s]*:[\s]*"[^"]*"[\s]*\}/g, "")
    .replace(/"title"[\s]*:[\s]*"[^"]*"/g, "")
    .replace(/"description"[\s]*:[\s]*"[^"]*"/g, "")
    .replace(/title[\s]*:[\s]*"[^"]*"/g, "")
    .replace(/description[\s]*:[\s]*"[^"]*"/g, "")
    .replace(/["'""]/g, "")
    .trim();

  // If the cleaned text is empty or too short, return original
  if (!cleaned || cleaned.length < 2) {
    return text;
  }

  return cleaned;
}

// Function to translate product information to Persian
async function translateToPersian(text: string): Promise<string> {
  if (!process.env.OPENAI_API_KEY) {
    return text;
  }

  // ÿß⁄Øÿ± ŸÖÿ™ŸÜ ÿÆÿßŸÑ€å €åÿß ÿÆ€åŸÑ€å ⁄©Ÿàÿ™ÿßŸá ÿ®ÿßÿ¥ÿØÿå ÿ¢ŸÜ ÿ±ÿß ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜ
  if (!text || text.trim().length < 3) {
    return text;
  }

  // Clean the text first
  const cleanedText = cleanTextForTranslation(text);

  // ÿß⁄Øÿ± ŸÖÿ™ŸÜ ŸÇÿ®ŸÑÿßŸã ŸÅÿßÿ±ÿ≥€å ÿßÿ≥ÿ™ÿå ÿ¢ŸÜ ÿ±ÿß ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜ
  if (isPersianText(cleanedText)) {
    return cleanedText;
  }

  try {
    const translationPrompt = `
      ÿß€åŸÜ ŸÖÿ™ŸÜ ÿ±ÿß ÿßÿ≤ ÿ™ÿ±⁄©€å €åÿß ÿßŸÜ⁄ØŸÑ€åÿ≥€å ÿ®Ÿá ŸÅÿßÿ±ÿ≥€å ÿ™ÿ±ÿ¨ŸÖŸá ⁄©ŸÜ. ŸÅŸÇÿ∑ ÿ™ÿ±ÿ¨ŸÖŸá ŸÅÿßÿ±ÿ≥€å ÿ±ÿß ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜÿå ÿ®ÿØŸàŸÜ ÿ™Ÿàÿ∂€åÿ≠ ÿßÿ∂ÿßŸÅ€å €åÿß ÿπŸÑÿßŸÖÿ™ ŸÜŸÇŸÑ ŸÇŸàŸÑ. ÿß⁄Øÿ± ŸÖÿ™ŸÜ ⁄©Ÿàÿ™ÿßŸá ÿßÿ≥ÿ™ÿå ÿ™ÿ±ÿ¨ŸÖŸá ⁄©Ÿàÿ™ÿßŸá Ÿà ÿØŸÇ€åŸÇ ÿßÿ±ÿßÿ¶Ÿá ⁄©ŸÜ:
      
      ŸÖÿ™ŸÜ: "${cleanedText}"
      
      ÿ™ÿ±ÿ¨ŸÖŸá ŸÅÿßÿ±ÿ≥€å:
    `;

    const { text: translatedText } = await generateText({
      model: openai("gpt-4o-mini"),
      prompt: translationPrompt,
      maxOutputTokens: 100,
      temperature: 0.1,
    });

    // Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ŸÜÿ™€åÿ¨Ÿá ÿ™ÿ±ÿ¨ŸÖŸá
    let cleanTranslation = translatedText.trim();

    // ÿ≠ÿ∞ŸÅ ÿπŸÑÿßŸÖÿ™‚ÄåŸáÿß€å ŸÜŸÇŸÑ ŸÇŸàŸÑ ÿßÿ≤ ÿßÿ®ÿ™ÿØÿß Ÿà ÿßŸÜÿ™Ÿáÿß
    cleanTranslation = cleanTranslation.replace(/^["'""]|["'""]$/g, "");

    // ÿ≠ÿ∞ŸÅ ⁄©ŸÑŸÖÿßÿ™ ÿßÿ∂ÿßŸÅ€å ŸÖÿ´ŸÑ "ÿ™ÿ±ÿ¨ŸÖŸá:" €åÿß "ŸÅÿßÿ±ÿ≥€å:"
    cleanTranslation = cleanTranslation.replace(/^(ÿ™ÿ±ÿ¨ŸÖŸá|ŸÅÿßÿ±ÿ≥€å|ŸÖÿ™ŸÜ):\s*/i, "");

    // ÿß⁄Øÿ± ÿ™ÿ±ÿ¨ŸÖŸá ÿÆÿßŸÑ€å €åÿß ÿÆ€åŸÑ€å ⁄©Ÿàÿ™ÿßŸá ÿ®ÿßÿ¥ÿØÿå ŸÖÿ™ŸÜ ÿßÿµŸÑ€å ÿ±ÿß ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜ
    if (!cleanTranslation || cleanTranslation.length < 2) {
      console.log(`‚ö†Ô∏è Translation failed for: "${cleanedText}"`);
      return cleanedText;
    }

    // ÿß⁄Øÿ± ÿ™ÿ±ÿ¨ŸÖŸá ŸáŸÖÿßŸÜ ŸÖÿ™ŸÜ ÿßÿµŸÑ€å ÿ®ÿßÿ¥ÿØÿå ÿ¢ŸÜ ÿ±ÿß ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜ
    if (cleanTranslation.toLowerCase() === cleanedText.toLowerCase()) {
      console.log(`‚ö†Ô∏è Translation unchanged for: "${cleanedText}"`);
      return cleanedText;
    }

    console.log(`‚úÖ Translated: "${cleanedText}" -> "${cleanTranslation}"`);
    return cleanTranslation;
  } catch (error) {
    console.error("‚ùå Error translating text:", error);
    return cleanedText;
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const query = searchParams.get("q");

    if (!query) {
      return NextResponse.json(
        { error: "Query parameter is required" },
        { status: 400 }
      );
    }

    console.log(`üîç Starting accessories search for query: "${query}"`);

    // Check if API keys are available
    if (!process.env.SERPAPI_KEY) {
      console.error("‚ùå SERPAPI_KEY is not configured");
      return NextResponse.json(
        { error: "Search service is not configured" },
        { status: 500 }
      );
    }

    // Enhance search query with OpenAI
    let enhancedQuery = await enhanceSearchQuery(query);

    console.log(`üîç Searching with enhanced query: "${enhancedQuery}"`);

    const serpApiParams = {
      engine: "google_shopping",
      q: enhancedQuery,
      gl: "tr", // ÿ™ÿ±⁄©€åŸá
      hl: "tr", // ÿ≤ÿ®ÿßŸÜ ÿ™ÿ±⁄©€å
      location: "Turkey",
      num: 50, // ÿßŸÅÿ≤ÿß€åÿ¥ ÿ™ÿπÿØÿßÿØ ŸÜÿ™ÿß€åÿ¨ ÿ®ÿ±ÿß€å ŸÅ€åŸÑÿ™ÿ± ⁄©ÿ±ÿØŸÜ ÿ®Ÿáÿ™ÿ±
      device: "desktop",
      api_key: process.env.SERPAPI_KEY,
    };

    console.log("üîç Search parameters:", serpApiParams);

    const shoppingResults = await getJson(serpApiParams);

    console.log("üîç Raw search results:", {
      hasResults: !!shoppingResults.shopping_results,
      resultCount: shoppingResults.shopping_results?.length || 0,
      searchInfo: shoppingResults.search_information,
    });

    if (
      !shoppingResults.shopping_results ||
      shoppingResults.shopping_results.length === 0
    ) {
      console.log("‚ùå No search results found");
      return NextResponse.json({
        products: [],
        message:
          "Ÿá€å⁄Ü ŸÑŸàÿßÿ≤ŸÖ ÿ¨ÿßŸÜÿ®€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã ⁄©ŸÑŸÖÿßÿ™ ⁄©ŸÑ€åÿØ€å ÿØ€å⁄Øÿ±€å ÿßŸÖÿ™ÿ≠ÿßŸÜ ⁄©ŸÜ€åÿØ.",
        search_query: query,
        enhanced_query: enhancedQuery,
      });
    }

    // Filter out computers and laptops
    const filteredResults = shoppingResults.shopping_results.filter(
      filterOutComputersAndLaptops
    );

    console.log(
      `üîç Filtered results: ${filteredResults.length} out of ${shoppingResults.shopping_results.length}`
    );

    if (filteredResults.length === 0) {
      return NextResponse.json({
        products: [],
        message:
          "Ÿá€å⁄Ü ŸÑŸàÿßÿ≤ŸÖ ÿ¨ÿßŸÜÿ®€å ŸÖŸÜÿßÿ≥ÿ® €åÿßŸÅÿ™ ŸÜÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã ⁄©ŸÑŸÖÿßÿ™ ⁄©ŸÑ€åÿØ€å ÿØ€å⁄Øÿ±€å ÿßŸÖÿ™ÿ≠ÿßŸÜ ⁄©ŸÜ€åÿØ.",
        search_query: query,
        enhanced_query: enhancedQuery,
      });
    }

    // Process and translate products
    const processedProducts = await Promise.all(
      filteredResults.slice(0, 20).map(async (product: any) => {
        const productLink = extractProductLink(product);

        // Translate title and description to Persian with better handling
        let translatedTitle = product.title || "";
        let translatedDescription = product.description || "";

        // Clean and validate title first
        if (translatedTitle) {
          translatedTitle = cleanTextForTranslation(translatedTitle);
        }

        // Clean and validate description first
        if (translatedDescription) {
          translatedDescription = cleanTextForTranslation(
            translatedDescription
          );
        }

        // Only translate if the text is not empty and not already in Persian
        if (translatedTitle && !isPersianText(translatedTitle)) {
          translatedTitle = await translateToPersian(translatedTitle);
        }

        // ÿ®Ÿáÿ®ŸàÿØ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ÿµŸàŸÑ
        if (translatedTitle) {
          translatedTitle = translatedTitle
            .replace(/\s+/g, " ") // ÿ≠ÿ∞ŸÅ ŸÅÿßÿµŸÑŸá‚ÄåŸáÿß€å ÿßÿ∂ÿßŸÅ€å
            .replace(/^\s+|\s+$/g, "") // ÿ≠ÿ∞ŸÅ ŸÅÿßÿµŸÑŸá ÿßÿ≤ ÿßÿ®ÿ™ÿØÿß Ÿà ÿßŸÜÿ™Ÿáÿß
            .replace(/["'""]/g, ""); // ÿ≠ÿ∞ŸÅ ÿπŸÑÿßŸÖÿ™‚ÄåŸáÿß€å ŸÜŸÇŸÑ ŸÇŸàŸÑ
        }

        if (translatedDescription && !isPersianText(translatedDescription)) {
          translatedDescription = await translateToPersian(
            translatedDescription
          );
        }

        // ÿß⁄Øÿ± ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™ ÿÆÿßŸÑ€å ÿ®ÿßÿ¥ÿØÿå ÿßÿ≤ ÿπŸÜŸàÿßŸÜ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ
        if (!translatedDescription && translatedTitle) {
          translatedDescription = translatedTitle;
        }

        // ÿ®Ÿáÿ®ŸàÿØ ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™ ⁄©Ÿàÿ™ÿßŸá
        if (translatedDescription && translatedDescription.length > 100) {
          translatedDescription =
            translatedDescription.substring(0, 100) + "...";
        }

        // ÿ≠ÿ∞ŸÅ ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ±Ÿáÿß€å ÿßÿ∂ÿßŸÅ€å ÿßÿ≤ ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™
        if (translatedDescription) {
          translatedDescription = translatedDescription
            .replace(/\s+/g, " ") // ÿ≠ÿ∞ŸÅ ŸÅÿßÿµŸÑŸá‚ÄåŸáÿß€å ÿßÿ∂ÿßŸÅ€å
            .replace(/^\s+|\s+$/g, "") // ÿ≠ÿ∞ŸÅ ŸÅÿßÿµŸÑŸá ÿßÿ≤ ÿßÿ®ÿ™ÿØÿß Ÿà ÿßŸÜÿ™Ÿáÿß
            .replace(/["'""]/g, ""); // ÿ≠ÿ∞ŸÅ ÿπŸÑÿßŸÖÿ™‚ÄåŸáÿß€å ŸÜŸÇŸÑ ŸÇŸàŸÑ
        }

        // Final validation - if description still contains JSON-like content, use title
        if (
          translatedDescription &&
          (translatedDescription.includes('"title"') ||
            translatedDescription.includes('"description"') ||
            translatedDescription.includes("title:") ||
            translatedDescription.includes("description:"))
        ) {
          translatedDescription = translatedTitle || "ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™ ŸÖÿ≠ÿµŸàŸÑ";
        }

        return {
          id: product.product_id || `product-${Date.now()}-${Math.random()}`,
          title: translatedTitle,
          originalTitle: product.title,
          price:
            parseFloat(
              product.price?.replace(/[^\d.,]/g, "").replace(",", ".")
            ) || 0,
          originalPrice: product.original_price
            ? parseFloat(
                product.original_price.replace(/[^\d.,]/g, "").replace(",", ".")
              )
            : null,
          currency: product.price?.replace(/[\d.,]/g, "").trim() || "TL",
          image: product.thumbnail || "",
          description: translatedDescription,
          originalDescription: product.description,
          link: productLink,
          googleShoppingLink: product.link,
          source: product.merchant?.name || "Unknown",
          rating: parseFloat(product.rating) || 0,
          reviews: parseInt(product.reviews) || 0,
          delivery: product.delivery || "ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿßÿ±ÿ≥ÿßŸÑ ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™",
        };
      })
    );

    console.log(
      `‚úÖ Processed ${processedProducts.length} accessories products`
    );

    return NextResponse.json({
      products: processedProducts,
      message: `${processedProducts.length} ŸÑŸàÿßÿ≤ŸÖ ÿ¨ÿßŸÜÿ®€å €åÿßŸÅÿ™ ÿ¥ÿØ`,
      search_query: query,
      enhanced_query: enhancedQuery,
    });
  } catch (error) {
    console.error("‚ùå Accessories search error:", error);
    return NextResponse.json(
      { error: "ÿÆÿ∑ÿß ÿØÿ± ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å ŸÑŸàÿßÿ≤ŸÖ ÿ¨ÿßŸÜÿ®€å. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ." },
      { status: 500 }
    );
  }
}
